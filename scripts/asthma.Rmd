---
title: "Exploratory and statistical analysis of RNA-seq data using DESeq2"
author: "Michael Love"
date: "June 2017"
abstract: "This workflow covers basic steps in an exploratory and statistical analysis of RNA-seq data, from import of Salmon quantifications, to performing differential gene expression and looking up annotation information about significant genes. The experimental data consists of control and virus treated samples from 6 asthmatic and 6 non-asthmatic individuals, where a given individual has both a control (Vehicle) and treated (HRV16) sample."
output:
  html_document:
    toc: true
    toc_float: true
---

```{r echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, fig.width=5, fig.height=5)
```

# Importing Salmon quant files

We begin this workflow by importing Salmon quantifications which are 
included in this repository under `data/quant`. Relative to the `scripts` 
directory, we can see we have quantifications for 24 samples:

```{r}
list.files("../data/quant/")
```

The layout of a single sample's quantification directory

```{r}
list.files("../data/quant/SRR1565926")
```

We will read in a table we created from the SRA website, which
gives some of the sample information. We call this table `coldata`,
because it provides data about the *columns* of the count matrix
we will be assembling.

```{r}
library(readr)
coldata <- read_delim("../data/SraRunTable.txt", delim="\t")
coldata
```

We have used the run ID (`SRR...`) to keep track of the reads and quantifications,
so we can build a vector which points to our quantification files using
this column of `coldata`. We use `names` to name this vector with the run IDs as well.

```{r}
files <- file.path("../data/quant",coldata$Run_s,"quant.sf.gz")
names(files) <- coldata$Run_s
head(files,2)
```

The following code (not evaluated here) can be used to generate a table
that connects transcripts to genes for summarizing Salmon transcript
quantifications for differential gene expression. We simply
read in the GTF file from the same database that we used for building
the Salmon index (in this case, Gencode version 26), and then pull
out a table with the transcript name for every gene.

```{r eval=FALSE}
# ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_26/gencode.v26.annotation.gtf.gz
library(GenomicFeatures)
txdb <- makeTxDbFromGFF("gencode.v26.annotation.gtf.gz")
saveDb(txdb, file="gencode.v26.sqlite")
# next time you can just load with this line (no need to makeTxDb...)
# txdb <- loadDb("gencode.v26.sqlite") 
columns(txdb)
k <- keys(txdb, "GENEID")
res <- AnnotationDbi::select(txdb, k, "TXNAME", "GENEID")
tx2gene <- res[,2:1]
```
	
We have prepared this table in advance, and now load it:
	
```{r}
load("../data/tx2gene.rda")
head(tx2gene)
```

Now we can use the `tximport` function to assemble all the quantifications
from the 24 files, and to summarize the abundances, counts and transcript
lengths to the gene level, for use with DESeq2 and other Bioconductor
packages.

It's a good idea to first test on a single quantification file, which we show here:

```{r}
library(rjson)
library(tximport)
txi <- tximport(files[1], type="salmon", tx2gene=tx2gene)
```

Now we can run `tximport` over all the quanfitication files.
We can see we obtain a list of matrices with common dimension:
58219 (the number of genes) x 24 (the number of samples).

```{r message=FALSE}
txi <- tximport(files, type="salmon", tx2gene=tx2gene)
names(txi)
dim(txi$abundance)
dim(txi$counts)
dim(txi$length)
```

Now we load DESeq2 for further steps in the workflow:

```{r message=FALSE}
library(DESeq2)
```

# Assembling the sample info

In the `coldata` table, we have information about which samples are from
asthmatic or non-asthmatic individuals, and which samples are control or treated.
Because we built `txi` using the run IDs, we know that these columns are
lined up with our columns of the matrices in `txi`.

```{r}
coldata$disease_state_s
coldata$treatment_s
```

While most of the information we need is in the `coldata` table already,
while preparing this data for analysis, I noticed that the same subjects had 
both a control (Vehicle) and treated (HRV16) sample, but I didn't find this
information from the SRA table. It was present, however, in the title of 
the samples listed on the GEO website, which also points to the run ID.
We can therefore bring in the sample names from GEO, line them up with
our coldata, and extract the subject ID information:

```{r}
geo <- read_delim("../data/GEO_table.txt", delim="\t", col_names=FALSE)
head(geo)
coldata$title <- geo$X2[match(coldata$Sample_Name_s, geo$X1)]
coldata$condition <- factor(coldata$disease_state_s)
coldata$treatment <- factor(coldata$treatment_s)
```

Now, we will build a `DESeqDataSet` from the matrices in `txi`, 
which we will use for the rest of the workflow. This function brings
along the estimated counts per gene, estimated by Salmon, as well as 
a normalizing offset based on the transcript lengths. This normalizing offset
adjusts for the *average transcript length* of a gene, which can be influenced
by differential isoform usage, as well as common RNA-seq biases,
if we used Salmon flags for correcting for various biases. Both of these effects 
-- differential isoform usage and technical biases -- 
can change the *effective length* of a gene, and so both are useful as
normalizing offsets in a statistical comparisons of counts across samples.

When building the `DESeqDataSet` we have to specify a *design*, which
is a formula in R that begins with a tilde and explains what terms, or coefficients,
we want to use to model the counts. The design is used by the dispersion estimation
and model fitting functions in DESeq2, so we can change it later, but we will have 
to rerun the main functions to re-estimate the parameters. 

For now, we will use a design that specifies a condition effect (asthmatics vs
non-asthmatics), a treatment effect (HRV16 vs Vehicle), and an interaction between 
the two (so the treatment effect can be different for asthmatics and non-asthmatics).
An interaction term is specified in R with a colon between two variables.
This design roughly corresponds to the goals of the original study.

```{r}
dds <- DESeqDataSetFromTximport(txi, coldata,
                                ~condition + treatment + condition:treatment)
dds
```

I like to rename the *levels* of the variables in the design so they are
easier to work with, by shortening them.

```{r}
# you can rename levels, but need to use same order as current levels()
levels(dds$condition)
levels(dds$condition) <- c("asth","non")
levels(dds$condition)
dds$condition
```

It's also important to set the *reference level* in a sensible way,
so comparisons are of treated over control for instance. In this 
case the reference levels should be the non-asthmatic individuals and the
Vehicle treatment.

We use the compound assignment operator `%<>%` from the magrittr package, 
which saves us a little extra typing, when we want to apply a function 
to a variable in R, and then re-assign it (so it is equivalent to `x <- f(x)`).

```{r}
library(magrittr)
dds$condition %<>% relevel("non")
dds$treatment %<>% relevel("Vehicle")
dds$condition
dds$treatment
```

# Exploratory data analysis

Already, we can take a look at how the samples related to each other.
In DESeq2, we have special functions for transforming the counts,
so that they can be easily visualized (we will not transform the counts, 
but use the raw counts later, for statistical testing).

My favorite of these transformation is the `vst`, mostly because it is 
very fast, and provides transformed (nearly log-scale) data which is
robust to many problems associated with log-transformed data (for more details,
see the DESeq2 
[workflow ](http://www.bioconductor.org/help/workflows/rnaseqGene/#the-rlog-and-variance-stabilizing-transformations)
or 
[vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#count-data-transformations)
).

`blind=FALSE` refers to the fact that we will use the *design* in estimating
the global scale of biological variability, but not directly in the transformation:

```{r}
vsd <- vst(dds, blind=FALSE)
```

Now that we have normalized and transformed the data, it will have roughly 
the same variance (except for differentially expressed genes) across the range of
counts, so from counts in the single digits, up to the most highly expressed 
genes with very high counts.

We can make a PCA plot, which shows the distribution of the samples
among the top two dimensions, in terms of the variance explained.
It's simply a rotation and projection of the transformed data, but 
picking the "best" 2 dimensions out of the tens of thousands (number of genes).

```{r pca, fig.width=7, fig.height=4}
plotPCA(vsd, c("treatment","condition"))
```

From the PCA plot, we see that the treatment with HRV16 leads to the most
variance across samples, for the top variable genes. There seems to be some
clustering by disease status (what we called `condition`), for the treated samples
but not much for the control samples.

# Re-arrange sample info

As we mentioned before, there is an additional piece of information
about the samples: the Vehicle and HRV16 treated samples are from
the same individual, so this is also important information to include
in the design, if possible. In this case, because we are comparing
control and HRV16 treatment within individuals, we can add this information 
to the design. First, we need to clean up the sample ID information
contained in the `title` variable:

```{r}
dds$id <- substr(dds$title, 1, 3)
dds$id
id.lvls <- c(dds$id[dds$condition == "non" & dds$treatment == "Vehicle"],
             dds$id[dds$condition == "asth" & dds$treatment == "Vehicle"])
id.lvls
```

We will re-factor the id, so that the levels are in the order
of the `id.lvls` variable we just defined.

We will then re-order the `DESeqDataSet` so that the
samples are in order by condition, treatment and ID.

```{r}
dds$id %<>% factor(levels=id.lvls)
o <- order(dds$condition, dds$treatment, dds$id)
dds <- dds[,o]
```

We can take a look at the `colData` to confirm it's in the order
as we want it to be:

```{r}
as.data.frame(colData(dds)[c("condition","treatment","id")])
all(dds$id == c(rep(id.lvls[1:6], 2),
                rep(id.lvls[7:12], 2)))
```

To make the within-individual treatment comparisons across 
condition, we need to do a little re-coding trick for the 
subject ID. We will re-code them so that the first asthmatic 
subject is called `1`, and the first non-asthmatic subject 
is also called `1`, which we call "nesting". 

Note that these two subjects will 
not be treated as the same in the model, because we will
include an interaction term between `condition` and `id.nested`.

```{r}
dds$id.nested <- factor(rep(1:6,4))
as.data.frame(colData(dds)[c("condition","treatment","id","id.nested")])
```

Now we update the design, so that each patient gets his or her 
own reference level for comparison of the treatment effect:

```{r}
design(dds) <- ~condition + condition:id.nested +
  treatment + condition:treatment
```

Before we run the differential expression steps,
we have one more data cleaning step to do. We will 
chop off the version number of the gene IDs, so that we 
can better look up their annotation information later.

However, we have a few genes which would have duplicated
gene IDs after chopping off the version number, so in order
to proceed we have to also use `make.unique` to indicate 
that some genes are duplicated. (It might be 
worth looking into why we have multiple versions of genes
with the same base ID coming from our annotation.)

```{r}
head(rownames(dds))
table(duplicated(substr(rownames(dds),1,15)))
rownames(dds) <- make.unique(substr(rownames(dds),1,15))
```

# Differential gene expression

Now we can run our differential expression pipeline.
First, it is sometimes convenient to remove genes where
all the samples have very small counts. It's less of an issue 
for the statistical methods, and mostly just wasted computation,
as it is not possible for these genes to exhibit statistical
significance for differential expression. Here we count
how many genes (out of those with at least a single count)
have 3 samples with a count of 10 or more:

```{r}
dds <- dds[rowSums(counts(dds)) > 0,]
keep <- rowSums(counts(dds) >= 10) >= 3
table(keep)
dds <- dds[keep,] # filter out them out
```

Now we can run the differential expression pipeline using
`DESeq` and extract the results using `results`.
These functions do a little of work for you, and
they have extensive help describing all their options,
which can be read by typing in `?DESeq` and `?results`.

We will build a results table for the coefficient
`conditionasth.treatmentHRV16`. This coefficient represents
the difference in the treatment effect in the asthmatic group
relative to the non-asthmatic group.

```{r}
dds <- DESeq(dds)
resultsNames(dds)
res <- results(dds, name="conditionasth.treatmentHRV16")
res.sort <- res[order(res$pvalue),]
```

A good visual summary of a results table is the "MA-plot".
M stands for "minus", as the y-axis for a simple two group
comparison is the difference between the log of the expression
values for each group. In general, and for this experiment, the y-axis
is the log2 fold change attributable to the coefficient or contrast
that was used in building the results table. The "A" stands for average,
as the x-axis indicates the average of normalized counts across 
all the samples in the dataset.

Because all of the points are grey, we know that none of the 
genes showed a significant difference in the treatment effect
across the two condition groups, at an FDR cutoff of 0.1 
(this is the default value for `plotMA`, and can be changed).

```{r plotma}
plotMA(res, ylim=c(-5,5))
```

We can also print out a summary table, which 
similarly tells us that, at an FDR cutoff of 0.1,
no genes were significantly differentially expressed
for our particular comparison.

```{r}
summary(res)
```

```{r echo=FALSE}
# to make plotCounts same each time
# (has random jitter)
# avoids inflation of git repo...
set.seed(1)
```

```{r topgene1}
top.gene <- rownames(res.sort)[1]
plotCounts(dds, top.gene, c("condition","treatment"), transform=FALSE)
```

# Exploring results

```{r}
library(Homo.sapiens)
Homo.sapiens %>% mapIds(top.gene, "SYMBOL", "ENSEMBL")
go.tab <- Homo.sapiens %>% AnnotationDbi::select(top.gene, "GOID", "ENSEMBL") %>% subset(ONTOLOGY == "BP")
# Homo.sapiens %>% AnnotationDbi::select(go.tab$GOID, "TERM", "GOID")
```

```{r}
target <- c("CCL5","CXCL10","CX3CL1","ACKR4","CDHR3")
target.map <- mapIds(Homo.sapiens, target, "ENSEMBL", "SYMBOL")
target.map
match(target.map, rownames(res.sort))
```

```{r targets}
plotCounts(dds, target.map[2], c("condition","treatment"))
plotCounts(dds, target.map[2], c("condition","treatment"), transform=FALSE)
```

```{r}
dat <- plotCounts(dds, target.map[2], c("condition","treatment","id.nested"),
                  returnData=TRUE)
```

```{r targets2, warning=FALSE, fig.width=7, fig.height=4}
library(ggplot2)
ggplot(dat, aes(x=treatment, y=count, col=id.nested, group=id.nested)) +
  geom_point() + geom_smooth(method="lm", se=FALSE) +
  scale_y_log10() + 
  facet_wrap(~condition)
```

# Interlude: power analysis

```{r plotdisp}
plotDispEsts(dds, ylim=c(1e-4,10))
```

```{r}
dispersionFunction(dds)
dmr <- function(x) (.05 + 2.06 / x) * exp(rnorm(length(x),0,.28))
baseMean <- mcols(dds)$baseMean
```

```{r simdisp}
plot(baseMean, dmr(baseMean), log="xy", ylim=c(1e-4,10))
```

```{r}
mean(log2(baseMean))
sd(log2(baseMean))
```

```{r}
set.seed(1)
sim <- makeExampleDESeqDataSet(n=10000, m=12,
                               betaSD=1,
                               interceptMean=5,
                               interceptSD=2,
                               dispMeanRel=dmr)
keep <- rowSums(counts(sim) >= 10) >= 3
table(keep)
sim <- sim[keep,]
sim <- DESeq(sim)
sim.res <- results(sim, independentFiltering=FALSE, cooksCutoff=FALSE)
```

```{r compma, fig.width=8, fig.height=5}
par(mfrow=c(1,2))
plotMA(res, xlim=c(1,1e6), ylim=c(-5,5))
plotMA(sim.res, xlim=c(1,1e6), ylim=c(-5,5))
```

```{r}
max.lfc <- ceiling(max(abs(mcols(sim)$trueBeta)))
sim.dat <- data.frame(sig=sim.res$padj < .1,
                      log2mean=cut(mcols(sim)$trueIntercept,c(-1,3.3,6.6,10,20)),
                      abs.lfc=cut(abs(mcols(sim)$trueBeta),c(0,.25,.5,1,max.lfc)))
```

```{r message=FALSE}
library(dplyr) 
sim.tab <- sim.dat %>% group_by(log2mean, abs.lfc) %>% summarize(power=mean(sig))
```

```{r power}
ggplot(sim.tab, aes(x=abs.lfc, y=power, col=log2mean, group=log2mean)) + geom_line()
```

```{r}
de <- rep(c(FALSE,TRUE),c(8000,2000))
set.seed(1)
sim2 <- makeExampleDESeqDataSet(n=10000, m=12,
                                betaSD=ifelse(de,1,0),
                                interceptMean=6,
                                interceptSD=3,
                                dispMeanRel=dmr)
sim2 <- DESeq(sim2)
threshold <- c(1,5,10,15,20)/100
FDR <- sapply(threshold, function(t) {
  sim2.res <- results(sim2, alpha=t)
  sig <- which(sim2.res$padj < t)
  mean(!de[sig])
})
```

```{r simfdr}
plot(threshold, FDR, ylim=c(0,.3), type="b", col="blue",
     main="Sim: empirical vs nominal FDR")
abline(0,1)
```

We can also do a quick power and precision analysis of 
DESeq2 calls using the highly replicated yeast RNA-seq dataset of 
[Schurch et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4878611/).

```{r}
load("../data/yeast.rda")
n <- 5
set.seed(1)
idx <- c(sample(which(yeast$condition == "WT"), n),
         sample(which(yeast$condition == "mut"), n))
yeast.in <- yeast[,idx]
yeast.out <- yeast[,-idx]
yeast.in <- DESeq(yeast.in)
yeast.out <- DESeq(yeast.out)
# use LFC threshold, otherwise "too easy": >2/3 genes DE
res.in <- results(yeast.in, lfcThreshold=1, alpha=.1)
res.out <- results(yeast.out, lfcThreshold=1, alpha=.01)
res.out$padj[is.na(res.out$padj)] <- 1 # set NA to 1
de <- res.out$padj < .01 # consider 'out' with 1% FDR as 'truth'
prop.table(table(test=res.in$padj < .1, de),1)
```

```{r}
sapply(threshold, function(t) {
  res.in <- results(yeast.in, lfcThreshold=1, alpha=t)
  sum(res.in$padj < t, na.rm=TRUE)
})
FDR <- sapply(threshold, function(t) {
  res.in <- results(yeast.in, lfcThreshold=1, alpha=t)
  sig <- which(res.in$padj < t)
  mean(!de[sig])
})
```

```{r yeastfdr}
plot(threshold, FDR, ylim=c(0,.3), type="b", col="blue",
     main="High replicate yeast: empirical vs nominal FDR")
abline(0,1)
```

# Other differential analyses

```{r}
dds2 <- removeResults(dds)
design(dds2) <- ~condition + treatment + condition:id.nested
dds2 <- DESeq(dds2)
resultsNames(dds2)
res2 <- results(dds2, name=c("treatment_HRV16_vs_Vehicle"))
res2 <- results(dds2, contrast=c("treatment","HRV16","Vehicle"))
```

```{r plotma2}
plotMA(res2, ylim=c(-10,10))
```

```{r}
summary(res2)
```

```{r}
res2.sort <- res2[order(res2$log2FoldChange, decreasing=TRUE),]
Homo.sapiens %>% mapIds(rownames(res2.sort)[1:40],
                        "SYMBOL", "ENSEMBL")
```

# Exploring results with annotation

```{r}
match(target.map, rownames(res2.sort))
go.tab <- Homo.sapiens %>% AnnotationDbi::select(rownames(res2.sort)[1],
                                  "GO", "ENSEMBL") %>% subset(ONTOLOGY == "BP")
```

```{r}
library(GO.db)
go.tab2 <- GO.db %>% AnnotationDbi::select(go.tab$GO, "TERM", "GOID")
substr(go.tab2$TERM, 1, 60)
getTerms <- function(n) {
  go.tab <- Homo.sapiens %>% AnnotationDbi::select(rownames(res2.sort)[n],
                                    "GO", "ENSEMBL") %>% subset(ONTOLOGY == "BP")
  go.tab2 <- Homo.sapiens %>% AnnotationDbi::select(go.tab$GO, "TERM", "GOID")
  substr(go.tab2$TERM, 1, 60)
}
```

```{r}
getTerms(2)
getTerms(3)
getTerms(4)
getTerms(5)
getTerms(6)
getTerms(7)
getTerms(8)
```

# LFC shrinkage

```{r}
dds3 <- removeResults(dds)
design(dds3) <- ~condition + treatment
```

```{r}
dds3 <- DESeq(dds3)
resultsNames(dds3)
res3 <- results(dds3, lfcThreshold=2)
res3shr <- lfcShrink(dds3, coef=3, res=res3)
```

```{r plotma3, fig.width=8, fig.height=5}
par(mfrow=c(1,2))
plotMA(res3, ylim=c(-12,12))
rs <- rowSums(counts(dds)[,dds$treatment == "Vehicle"])
with(res3[rs < 12,], points(baseMean, log2FoldChange, cex=2, col="dodgerblue"))
plotMA(res3shr, ylim=c(-12,12))
with(res3shr[rs < 12,], points(baseMean, log2FoldChange, cex=2, col="dodgerblue"))
```

```{r}
sessionInfo()
```
